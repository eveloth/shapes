namespace Shapes;

public class Calculator
{
    // Это бесполезный метод, цель которого, на самом деле, оставить комментарий о
    // том, что -- в случае, если под неизвестным типом во время компиляции
    // подразумевался *конекретный* тип, это условие выполнено -- по ссылке
    // родительского класса будет вызван метод класса-наследника в том случае,
    // если не был использован механизм сокрытия.
    public double CalculateArea(Shape shape) => shape.Area();

    // Есть наивное решение без использования ООП вообще --
    // реализовать два метода, один из которых по трем сторонам будет считать
    // площадь треугольника, другой -- площадь круга; это плохое нерасширяемое и
    // нетипобезопасное решение, но оно есть. Сомнительно но окэй..
    public double TriangleArea(double a, double b, double c)
    {
        var p = (a + b + c) / 2;
        return Math.Sqrt(p * (p - a) * (p - b) * (p - c));
    }

    public double CircleArea(double radius) => Math.PI * radius * radius;

    // Клиентский код, вызывающий эти методы, не получит от API нашей библиотеки никакого фидбэка,
    // если просто передаст туда три случайных числа (по ошибке)
    
    // У меня было много гипотез по поводу того, что с этим можно ещё сделать -- 
    // но я посчитал, что достаточно бессмысленно использовать рефлексию, и, к примеру, позволять
    // клиентскому коду передавать object, а затем доставать из него необходимые свойства
    // по конвенции -- если мы предоставляем калькулятор площади, то логично предоставить и фигуры --
    // все необходимые методы и свойства на них уже будут, и никакие дополнительные классы нам не нужны.
    // Помимо прочего можно передавать нетипизированный объект с хинтом в виде, к примеру, строкового
    // (или в виде enum) обозначения типа объекта, но.. зачем? Нам до сих пор -- на момент .NET 8 --
    // приходится доставать метаданные эндпоинтов через рефлексию, потому что оно так задизайнено,
    // поэтому такого добра хватает и без того, чтобы писать его самому :)
    // (Привет доставанию значения Route после собственно роутинга из middleware)
}
